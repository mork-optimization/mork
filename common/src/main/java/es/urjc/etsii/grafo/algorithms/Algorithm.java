package es.urjc.etsii.grafo.algorithms;

import es.urjc.etsii.grafo.annotations.AlgorithmComponent;
import es.urjc.etsii.grafo.create.builder.SolutionBuilder;
import es.urjc.etsii.grafo.io.Instance;
import es.urjc.etsii.grafo.solution.Solution;

import java.util.Objects;


/**
 * Base algorithm class, all algorithms should extend this class or any of its subclasses.
 *
 * @param <S> Solution class
 * @param <I> Instance class
 */
@AlgorithmComponent
public abstract class Algorithm<S extends Solution<S, I>, I extends Instance> {

    private SolutionBuilder<S, I> builder;
    private String algorithmName;

    /**
     * Initialize common algorithm fields
     *
     * @param algorithmName algorithm name. See {@link #setName(String)}
     */
    protected Algorithm(String algorithmName) {
        this.algorithmName = algorithmName;
    }

    /**
     * Algorithm name, uniquely identifies the algorithm inside an experiment
     *
     * @return algorithm name
     */
    public String getName() {
        return this.algorithmName;
    }

    /**
     * Sets the algorithm name.
     * This method can be called after the algorithm has been built,
     * for example if we want to customize the name generated by the autoconfig module.
     * This method CANNOT be called after the algorithm has started executing, as it would break the experiment results.
     * The algorithm name is used to uniquely identify the algorithm inside an experiment.
     *
     * @param algorithmName must uniquely identify the algorithm inside an experiment
     */
    public void setName(String algorithmName) {
        this.algorithmName = algorithmName;
    }

    /**
     * Runs the algorithm
     *
     * @param instance Instance to solve
     * @return Built solution
     */
    public abstract S algorithm(I instance);

    /**
     * Create a new solution for the given instance. Solution is empty by default.
     *
     * @param instance Instance
     * @return Empty solution, by default created calling the constructor Solution(Instance i)
     */
    public S newSolution(I instance) {
        return this.builder.initializeSolution(instance);
    }

    /**
     * Get solution builder
     *
     * @return solution builder
     */
    protected SolutionBuilder<S, I> getBuilder() {
        return builder;
    }

    /**
     * Set solution builder, used by the framework.
     * In case an algorithms contains another algorithms, this method should be overridden as follows:
     * <pre>
     *     &#64;Override
     *     public void setBuilder(SolutionBuilder&#60;S, I&#62; builder) {
     *         super.setBuilder(builder);
     *         this.algorithm.setBuilder(builder);
     *     }
     * </pre>
     *
     * @param builder solution builder
     */
    public void setBuilder(SolutionBuilder<S, I> builder) {
        this.builder = Objects.requireNonNull(builder);
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName() + "{" +
                "name='" + algorithmName + '\'' +
                '}';
    }
}
